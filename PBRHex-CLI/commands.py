# pylint: disable=missing-class-docstring,missing-function-docstring
"""Generates a C# partial class in accordance
with the commands contained in a json file
"""
import json
from pathlib import Path
from argparse import (
    ArgumentParser,
    Namespace
)
from typing import Any

JsonObj = dict[str, Any]


def kebab_to_camel_case(name: str) -> str:
    tokens = name.split('-')
    return tokens[0] + ''.join(token.capitalize() for token in tokens[1:])


def kebab_to_pascal_case(name: str) -> str:
    return ''.join(token.capitalize() for token in name.split('-'))


class CommandCodeGenerator:

    commands: list[JsonObj]

    def __init__(self,
                 namespace: str,
                 classname: str,
                 tab_size: int = 4):
        self.namespace = namespace
        self.classname = classname
        self.tab_size = tab_size

        self.commands = []

    @property
    def tab(self):
        return ' ' * self.tab_size

    def load_commands(self,
                      path: Path,
                      encoding: str = 'utf-8'):
        self.commands = []

        with open(path, encoding=encoding) as file:
            commands = json.load(file)

        assert isinstance(commands, list)
        assert all(isinstance(e, dict) for e in commands)

        self.commands = commands

    def _format_lines(self, lines: list[str], indent: int) -> str:
        tab = self.tab * indent

        output = ""
        for i, line in enumerate(lines):
            line = line.strip()
            if i > 0 and len(line) > 0:
                line = tab + line
            output += line + '\n'

        return output[:-1]

    def get_source_code(self) -> str:
        source = f"""// Auto-generated by commands.py
using System.CommandLine;

namespace {self.namespace}
{{
    internal partial class {self.classname}
    {{
        private readonly Dictionary<string, Command> Commands = new();

        private void InitCommands() {{
            {self._gen_add_commands(indent=3)}
        }}

        {self._gen_add_command_methods(indent=2)}

        {self._gen_partial_methods(indent=2)}
    }}
}}
"""
        return source

    def _gen_add_commands(self, indent: int = 0) -> str:
        lines: list[str] = []

        for command in self.commands:
            name_str = f"\"{command['name']}\""
            method_name = self._get_create_command_method_name(command)
            lines.append(f"Commands.Add({name_str}, {method_name}());")

        return self._format_lines(lines, indent)

    def _gen_add_command_methods(self, indent: int = 0) -> str:
        lines: list[str] = []

        for command in self.commands:
            method_source = self._gen_add_command_method(command, indent=2)
            lines.append(method_source)
            lines.append('')

        return self._format_lines(lines[:-1], indent)

    def _gen_add_command_method(self,
                                command: JsonObj,
                                indent: int = 0) -> str:
        method_name = self._get_create_command_method_name(command)
        body = self._gen_add_command_method_body(command)
        tab = self.tab * indent

        lines = f"""
{tab}private Command {method_name}() {{
{tab}{self.tab}{self._format_lines(body, indent + 1)}
{tab}}}
"""
        return lines

    def _gen_add_command_method_body(self, command: JsonObj) -> list[str]:
        body: list[str] = []

        name_str = f"\"{command['name']}\""
        desc_str = f"\"{command['description']}\""
        body.append(f"Command command = new({name_str}, {desc_str});")
        if 'alias' in command:
            body.append(f"command.AddAlias(\"{command['alias']}\");")
        body.append('')

        arg_names, arg_statements = self._gen_command_arguments(command)
        if len(arg_statements) > 0:
            body += arg_statements
            body.append('')

        method_name = self._get_handle_method_name(command)
        for arg in arg_names:
            body.append(f"command.Add({arg});")
        args = ''.join(', ' + arg for arg in arg_names)
        body.append(f"command.SetHandler({method_name}{args});")

        body.append('')
        body.append('return command;')

        return body

    def _gen_command_arguments(self, command: JsonObj) -> tuple[list[str], list[str]]:
        arg_statements: list[str] = []

        arg_names: list[str] = []
        for argument in command['arguments']:
            name = self._get_argument_name(argument)
            arg_names.append(name)

            name_str = f"\"{argument['name']}\""
            desc_str = f"\"{argument['description']}\""
            arg_statements.append(
                f"Argument<string> {name} = new({name_str}, {desc_str});")

            if 'default' in argument:
                arg_statements.append(
                    f"{name}.SetDefaultValue(\"{argument['default']}\");")

        return arg_names, arg_statements

    def _gen_partial_methods(self, indent: int = 0) -> str:
        lines: list[str] = []

        for command in self.commands:
            method_name = self._get_handle_method_name(command)
            params = ', '.join(self._gen_method_param_list(command))
            lines.append(f"private partial void {method_name}({params});")

        return self._format_lines(lines, indent)

    def _gen_method_param_list(self, command: JsonObj) -> list[str]:
        args: list[str] = []

        for arg in command['arguments']:
            name = arg['name']
            type_ = arg['type'] if 'type' in arg else 'string'
            args.append(f"{type_} {name}")

        return args

    def _get_create_command_method_name(self, command: JsonObj) -> str:
        name = kebab_to_pascal_case(command['name'])
        return 'Create' + name + 'Command'

    def _get_handle_method_name(self, command: JsonObj) -> str:
        name = kebab_to_pascal_case(command['name'])
        return name + 'Handle'

    def _get_argument_name(self, argument: JsonObj) -> str:
        name = kebab_to_camel_case(argument['name'])
        return name + 'Argument'


def parse_args() -> Namespace:
    parser = ArgumentParser()

    parser.add_argument('infile', type=Path)
    parser.add_argument('outfile', type=Path)
    parser.add_argument('namespace')
    parser.add_argument('classname')
    parser.add_argument('--tab-size', type=int, default=4)

    return parser.parse_args()


def generate_csharp_file():
    args = parse_args()

    generator = CommandCodeGenerator(args.namespace, args.classname)
    generator.load_commands(args.infile)

    source = generator.get_source_code()

    with open(args.outfile, 'w+', encoding='utf-8') as file:
        file.write(source)


if __name__ == '__main__':
    generate_csharp_file()
