<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#
(Type, int)[] types = { (typeof(Int16), 2), (typeof(Int32), 4), (typeof(Int64), 8),
                        (typeof(UInt16), 2), (typeof(UInt32), 4), (typeof(UInt64), 8),
                        (typeof(Single), 4), (typeof(Double), 8)};
#>
using System;
using System.Buffers.Binary;
using System.IO;
using System.Text;

namespace PBRHex.Core.IO
{
    public enum Endianness
    {
        LittleEndian,
        BigEndian
    }

    public interface IByteStream
    {
        Endianness Endianness { get; }
        byte[] ReadBytes(long offset, int count);
    }

    internal class BytesReader
    {
        private readonly IByteStream stream;

        internal BytesReader(IByteStream stream) {
            this.stream = stream;
        }

        internal byte ReadByte(long offset) {
            byte[] bytes = stream.ReadBytes(offset, 1);
            return bytes[0];
        }

<# foreach ((Type type, int size) in types) { #>
        internal <#= type.Name #> Read<#= type.Name #>(long offset) {
            byte[] bytes = stream.ReadBytes(offset, <#= size #>);
            
            return stream.Endianness == Endianness.BigEndian
                ? BinaryPrimitives.Read<#= type.Name #>BigEndian(bytes)
                : BinaryPrimitives.Read<#= type.Name #>LittleEndian(bytes);
        }

<# } #>
        internal string ReadString(long offset, int? length = null) {
            StringBuilder sb = new();
            char c;

            if (length is null) {
                // Null-terminated strings
                while ((c = (char)ReadByte(offset)) != '\0') {
                    sb.Append(c);
                    offset++;
                }
            }
            else {
                // Fixed-length strings
                for (int i = 0; i < length; i++) {
                    c = (char)ReadByte(offset);
                    sb.Append(c);
                }
            }

            return sb.ToString();
        }
    }
}
